/* task.c generated by valac 0.46.5, the Vala compiler
 * generated from task.vala, do not modify */

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>

#define SEAFILE_TYPE_TASK (seafile_task_get_type ())
#define SEAFILE_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_TASK, SeafileTask))
#define SEAFILE_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_TASK, SeafileTaskClass))
#define SEAFILE_IS_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_TASK))
#define SEAFILE_IS_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_TASK))
#define SEAFILE_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_TASK, SeafileTaskClass))

typedef struct _SeafileTask SeafileTask;
typedef struct _SeafileTaskClass SeafileTaskClass;
typedef struct _SeafileTaskPrivate SeafileTaskPrivate;
enum  {
	SEAFILE_TASK_0_PROPERTY,
	SEAFILE_TASK_TTYPE_PROPERTY,
	SEAFILE_TASK_REPO_ID_PROPERTY,
	SEAFILE_TASK_STATE_PROPERTY,
	SEAFILE_TASK_RT_STATE_PROPERTY,
	SEAFILE_TASK_BLOCK_TOTAL_PROPERTY,
	SEAFILE_TASK_BLOCK_DONE_PROPERTY,
	SEAFILE_TASK_FS_OBJECTS_TOTAL_PROPERTY,
	SEAFILE_TASK_FS_OBJECTS_DONE_PROPERTY,
	SEAFILE_TASK_RATE_PROPERTY,
	SEAFILE_TASK_NUM_PROPERTIES
};
static GParamSpec* seafile_task_properties[SEAFILE_TASK_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))

#define SEAFILE_TYPE_CLONE_TASK (seafile_clone_task_get_type ())
#define SEAFILE_CLONE_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SEAFILE_TYPE_CLONE_TASK, SeafileCloneTask))
#define SEAFILE_CLONE_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SEAFILE_TYPE_CLONE_TASK, SeafileCloneTaskClass))
#define SEAFILE_IS_CLONE_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SEAFILE_TYPE_CLONE_TASK))
#define SEAFILE_IS_CLONE_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SEAFILE_TYPE_CLONE_TASK))
#define SEAFILE_CLONE_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SEAFILE_TYPE_CLONE_TASK, SeafileCloneTaskClass))

typedef struct _SeafileCloneTask SeafileCloneTask;
typedef struct _SeafileCloneTaskClass SeafileCloneTaskClass;
typedef struct _SeafileCloneTaskPrivate SeafileCloneTaskPrivate;
enum  {
	SEAFILE_CLONE_TASK_0_PROPERTY,
	SEAFILE_CLONE_TASK_STATE_PROPERTY,
	SEAFILE_CLONE_TASK_ERROR_PROPERTY,
	SEAFILE_CLONE_TASK_REPO_ID_PROPERTY,
	SEAFILE_CLONE_TASK_REPO_NAME_PROPERTY,
	SEAFILE_CLONE_TASK_WORKTREE_PROPERTY,
	SEAFILE_CLONE_TASK_NUM_PROPERTIES
};
static GParamSpec* seafile_clone_task_properties[SEAFILE_CLONE_TASK_NUM_PROPERTIES];

struct _SeafileTask {
	GObject parent_instance;
	SeafileTaskPrivate * priv;
};

struct _SeafileTaskClass {
	GObjectClass parent_class;
};

struct _SeafileTaskPrivate {
	gchar* _ttype;
	gchar* _repo_id;
	gchar* _state;
	gchar* _rt_state;
	gint64 _block_total;
	gint64 _block_done;
	gint _fs_objects_total;
	gint _fs_objects_done;
	gint _rate;
};

struct _SeafileCloneTask {
	GObject parent_instance;
	SeafileCloneTaskPrivate * priv;
};

struct _SeafileCloneTaskClass {
	GObjectClass parent_class;
};

struct _SeafileCloneTaskPrivate {
	gchar* _state;
	gint _error;
	gchar* _repo_id;
	gchar* _repo_name;
	gchar* _worktree;
};

static gint SeafileTask_private_offset;
static gpointer seafile_task_parent_class = NULL;
static gint SeafileCloneTask_private_offset;
static gpointer seafile_clone_task_parent_class = NULL;

GType seafile_task_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SeafileTask, g_object_unref)
SeafileTask* seafile_task_new (void);
SeafileTask* seafile_task_construct (GType object_type);
const gchar* seafile_task_get_ttype (SeafileTask* self);
void seafile_task_set_ttype (SeafileTask* self,
                             const gchar* value);
const gchar* seafile_task_get_repo_id (SeafileTask* self);
void seafile_task_set_repo_id (SeafileTask* self,
                               const gchar* value);
const gchar* seafile_task_get_state (SeafileTask* self);
void seafile_task_set_state (SeafileTask* self,
                             const gchar* value);
const gchar* seafile_task_get_rt_state (SeafileTask* self);
void seafile_task_set_rt_state (SeafileTask* self,
                                const gchar* value);
gint64 seafile_task_get_block_total (SeafileTask* self);
void seafile_task_set_block_total (SeafileTask* self,
                                   gint64 value);
gint64 seafile_task_get_block_done (SeafileTask* self);
void seafile_task_set_block_done (SeafileTask* self,
                                  gint64 value);
gint seafile_task_get_fs_objects_total (SeafileTask* self);
void seafile_task_set_fs_objects_total (SeafileTask* self,
                                        gint value);
gint seafile_task_get_fs_objects_done (SeafileTask* self);
void seafile_task_set_fs_objects_done (SeafileTask* self,
                                       gint value);
gint seafile_task_get_rate (SeafileTask* self);
void seafile_task_set_rate (SeafileTask* self,
                            gint value);
static void seafile_task_finalize (GObject * obj);
static void _vala_seafile_task_get_property (GObject * object,
                                      guint property_id,
                                      GValue * value,
                                      GParamSpec * pspec);
static void _vala_seafile_task_set_property (GObject * object,
                                      guint property_id,
                                      const GValue * value,
                                      GParamSpec * pspec);
GType seafile_clone_task_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SeafileCloneTask, g_object_unref)
SeafileCloneTask* seafile_clone_task_new (void);
SeafileCloneTask* seafile_clone_task_construct (GType object_type);
const gchar* seafile_clone_task_get_state (SeafileCloneTask* self);
void seafile_clone_task_set_state (SeafileCloneTask* self,
                                   const gchar* value);
gint seafile_clone_task_get_error (SeafileCloneTask* self);
void seafile_clone_task_set_error (SeafileCloneTask* self,
                                   gint value);
const gchar* seafile_clone_task_get_repo_id (SeafileCloneTask* self);
void seafile_clone_task_set_repo_id (SeafileCloneTask* self,
                                     const gchar* value);
const gchar* seafile_clone_task_get_repo_name (SeafileCloneTask* self);
void seafile_clone_task_set_repo_name (SeafileCloneTask* self,
                                       const gchar* value);
const gchar* seafile_clone_task_get_worktree (SeafileCloneTask* self);
void seafile_clone_task_set_worktree (SeafileCloneTask* self,
                                      const gchar* value);
static void seafile_clone_task_finalize (GObject * obj);
static void _vala_seafile_clone_task_get_property (GObject * object,
                                            guint property_id,
                                            GValue * value,
                                            GParamSpec * pspec);
static void _vala_seafile_clone_task_set_property (GObject * object,
                                            guint property_id,
                                            const GValue * value,
                                            GParamSpec * pspec);

static inline gpointer
seafile_task_get_instance_private (SeafileTask* self)
{
	return G_STRUCT_MEMBER_P (self, SeafileTask_private_offset);
}

SeafileTask*
seafile_task_construct (GType object_type)
{
	SeafileTask * self = NULL;
	self = (SeafileTask*) g_object_new (object_type, NULL);
	return self;
}

SeafileTask*
seafile_task_new (void)
{
	return seafile_task_construct (SEAFILE_TYPE_TASK);
}

const gchar*
seafile_task_get_ttype (SeafileTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_ttype;
	result = _tmp0_;
	return result;
}

void
seafile_task_set_ttype (SeafileTask* self,
                        const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_task_get_ttype (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_ttype);
		self->priv->_ttype = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_TTYPE_PROPERTY]);
	}
}

const gchar*
seafile_task_get_repo_id (SeafileTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}

void
seafile_task_set_repo_id (SeafileTask* self,
                          const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_task_get_repo_id (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_repo_id);
		self->priv->_repo_id = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_REPO_ID_PROPERTY]);
	}
}

const gchar*
seafile_task_get_state (SeafileTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_state;
	result = _tmp0_;
	return result;
}

void
seafile_task_set_state (SeafileTask* self,
                        const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_task_get_state (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_state);
		self->priv->_state = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_STATE_PROPERTY]);
	}
}

const gchar*
seafile_task_get_rt_state (SeafileTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_rt_state;
	result = _tmp0_;
	return result;
}

void
seafile_task_set_rt_state (SeafileTask* self,
                           const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_task_get_rt_state (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_rt_state);
		self->priv->_rt_state = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_RT_STATE_PROPERTY]);
	}
}

gint64
seafile_task_get_block_total (SeafileTask* self)
{
	gint64 result;
	g_return_val_if_fail (self != NULL, 0LL);
	result = self->priv->_block_total;
	return result;
}

void
seafile_task_set_block_total (SeafileTask* self,
                              gint64 value)
{
	g_return_if_fail (self != NULL);
	if (seafile_task_get_block_total (self) != value) {
		self->priv->_block_total = value;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_BLOCK_TOTAL_PROPERTY]);
	}
}

gint64
seafile_task_get_block_done (SeafileTask* self)
{
	gint64 result;
	g_return_val_if_fail (self != NULL, 0LL);
	result = self->priv->_block_done;
	return result;
}

void
seafile_task_set_block_done (SeafileTask* self,
                             gint64 value)
{
	g_return_if_fail (self != NULL);
	if (seafile_task_get_block_done (self) != value) {
		self->priv->_block_done = value;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_BLOCK_DONE_PROPERTY]);
	}
}

gint
seafile_task_get_fs_objects_total (SeafileTask* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_fs_objects_total;
	return result;
}

void
seafile_task_set_fs_objects_total (SeafileTask* self,
                                   gint value)
{
	g_return_if_fail (self != NULL);
	if (seafile_task_get_fs_objects_total (self) != value) {
		self->priv->_fs_objects_total = value;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_FS_OBJECTS_TOTAL_PROPERTY]);
	}
}

gint
seafile_task_get_fs_objects_done (SeafileTask* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_fs_objects_done;
	return result;
}

void
seafile_task_set_fs_objects_done (SeafileTask* self,
                                  gint value)
{
	g_return_if_fail (self != NULL);
	if (seafile_task_get_fs_objects_done (self) != value) {
		self->priv->_fs_objects_done = value;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_FS_OBJECTS_DONE_PROPERTY]);
	}
}

gint
seafile_task_get_rate (SeafileTask* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_rate;
	return result;
}

void
seafile_task_set_rate (SeafileTask* self,
                       gint value)
{
	g_return_if_fail (self != NULL);
	if (seafile_task_get_rate (self) != value) {
		self->priv->_rate = value;
		g_object_notify_by_pspec ((GObject *) self, seafile_task_properties[SEAFILE_TASK_RATE_PROPERTY]);
	}
}

static void
seafile_task_class_init (SeafileTaskClass * klass,
                         gpointer klass_data)
{
	seafile_task_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &SeafileTask_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_task_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_task_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_task_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_TTYPE_PROPERTY, seafile_task_properties[SEAFILE_TASK_TTYPE_PROPERTY] = g_param_spec_string ("ttype", "ttype", "ttype", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_REPO_ID_PROPERTY, seafile_task_properties[SEAFILE_TASK_REPO_ID_PROPERTY] = g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_STATE_PROPERTY, seafile_task_properties[SEAFILE_TASK_STATE_PROPERTY] = g_param_spec_string ("state", "state", "state", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_RT_STATE_PROPERTY, seafile_task_properties[SEAFILE_TASK_RT_STATE_PROPERTY] = g_param_spec_string ("rt-state", "rt-state", "rt-state", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_BLOCK_TOTAL_PROPERTY, seafile_task_properties[SEAFILE_TASK_BLOCK_TOTAL_PROPERTY] = g_param_spec_int64 ("block-total", "block-total", "block-total", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_BLOCK_DONE_PROPERTY, seafile_task_properties[SEAFILE_TASK_BLOCK_DONE_PROPERTY] = g_param_spec_int64 ("block-done", "block-done", "block-done", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_FS_OBJECTS_TOTAL_PROPERTY, seafile_task_properties[SEAFILE_TASK_FS_OBJECTS_TOTAL_PROPERTY] = g_param_spec_int ("fs-objects-total", "fs-objects-total", "fs-objects-total", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_FS_OBJECTS_DONE_PROPERTY, seafile_task_properties[SEAFILE_TASK_FS_OBJECTS_DONE_PROPERTY] = g_param_spec_int ("fs-objects-done", "fs-objects-done", "fs-objects-done", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_TASK_RATE_PROPERTY, seafile_task_properties[SEAFILE_TASK_RATE_PROPERTY] = g_param_spec_int ("rate", "rate", "rate", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
seafile_task_instance_init (SeafileTask * self,
                            gpointer klass)
{
	self->priv = seafile_task_get_instance_private (self);
}

static void
seafile_task_finalize (GObject * obj)
{
	SeafileTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_TASK, SeafileTask);
	_g_free0 (self->priv->_ttype);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_state);
	_g_free0 (self->priv->_rt_state);
	G_OBJECT_CLASS (seafile_task_parent_class)->finalize (obj);
}

GType
seafile_task_get_type (void)
{
	static volatile gsize seafile_task_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_task_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileTaskClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_task_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileTask), 0, (GInstanceInitFunc) seafile_task_instance_init, NULL };
		GType seafile_task_type_id;
		seafile_task_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileTask", &g_define_type_info, 0);
		SeafileTask_private_offset = g_type_add_instance_private (seafile_task_type_id, sizeof (SeafileTaskPrivate));
		g_once_init_leave (&seafile_task_type_id__volatile, seafile_task_type_id);
	}
	return seafile_task_type_id__volatile;
}

static void
_vala_seafile_task_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec)
{
	SeafileTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_TASK, SeafileTask);
	switch (property_id) {
		case SEAFILE_TASK_TTYPE_PROPERTY:
		g_value_set_string (value, seafile_task_get_ttype (self));
		break;
		case SEAFILE_TASK_REPO_ID_PROPERTY:
		g_value_set_string (value, seafile_task_get_repo_id (self));
		break;
		case SEAFILE_TASK_STATE_PROPERTY:
		g_value_set_string (value, seafile_task_get_state (self));
		break;
		case SEAFILE_TASK_RT_STATE_PROPERTY:
		g_value_set_string (value, seafile_task_get_rt_state (self));
		break;
		case SEAFILE_TASK_BLOCK_TOTAL_PROPERTY:
		g_value_set_int64 (value, seafile_task_get_block_total (self));
		break;
		case SEAFILE_TASK_BLOCK_DONE_PROPERTY:
		g_value_set_int64 (value, seafile_task_get_block_done (self));
		break;
		case SEAFILE_TASK_FS_OBJECTS_TOTAL_PROPERTY:
		g_value_set_int (value, seafile_task_get_fs_objects_total (self));
		break;
		case SEAFILE_TASK_FS_OBJECTS_DONE_PROPERTY:
		g_value_set_int (value, seafile_task_get_fs_objects_done (self));
		break;
		case SEAFILE_TASK_RATE_PROPERTY:
		g_value_set_int (value, seafile_task_get_rate (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_seafile_task_set_property (GObject * object,
                                 guint property_id,
                                 const GValue * value,
                                 GParamSpec * pspec)
{
	SeafileTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_TASK, SeafileTask);
	switch (property_id) {
		case SEAFILE_TASK_TTYPE_PROPERTY:
		seafile_task_set_ttype (self, g_value_get_string (value));
		break;
		case SEAFILE_TASK_REPO_ID_PROPERTY:
		seafile_task_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_TASK_STATE_PROPERTY:
		seafile_task_set_state (self, g_value_get_string (value));
		break;
		case SEAFILE_TASK_RT_STATE_PROPERTY:
		seafile_task_set_rt_state (self, g_value_get_string (value));
		break;
		case SEAFILE_TASK_BLOCK_TOTAL_PROPERTY:
		seafile_task_set_block_total (self, g_value_get_int64 (value));
		break;
		case SEAFILE_TASK_BLOCK_DONE_PROPERTY:
		seafile_task_set_block_done (self, g_value_get_int64 (value));
		break;
		case SEAFILE_TASK_FS_OBJECTS_TOTAL_PROPERTY:
		seafile_task_set_fs_objects_total (self, g_value_get_int (value));
		break;
		case SEAFILE_TASK_FS_OBJECTS_DONE_PROPERTY:
		seafile_task_set_fs_objects_done (self, g_value_get_int (value));
		break;
		case SEAFILE_TASK_RATE_PROPERTY:
		seafile_task_set_rate (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static inline gpointer
seafile_clone_task_get_instance_private (SeafileCloneTask* self)
{
	return G_STRUCT_MEMBER_P (self, SeafileCloneTask_private_offset);
}

SeafileCloneTask*
seafile_clone_task_construct (GType object_type)
{
	SeafileCloneTask * self = NULL;
	self = (SeafileCloneTask*) g_object_new (object_type, NULL);
	return self;
}

SeafileCloneTask*
seafile_clone_task_new (void)
{
	return seafile_clone_task_construct (SEAFILE_TYPE_CLONE_TASK);
}

const gchar*
seafile_clone_task_get_state (SeafileCloneTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_state;
	result = _tmp0_;
	return result;
}

void
seafile_clone_task_set_state (SeafileCloneTask* self,
                              const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_clone_task_get_state (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_state);
		self->priv->_state = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_clone_task_properties[SEAFILE_CLONE_TASK_STATE_PROPERTY]);
	}
}

gint
seafile_clone_task_get_error (SeafileCloneTask* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_error;
	return result;
}

void
seafile_clone_task_set_error (SeafileCloneTask* self,
                              gint value)
{
	g_return_if_fail (self != NULL);
	if (seafile_clone_task_get_error (self) != value) {
		self->priv->_error = value;
		g_object_notify_by_pspec ((GObject *) self, seafile_clone_task_properties[SEAFILE_CLONE_TASK_ERROR_PROPERTY]);
	}
}

const gchar*
seafile_clone_task_get_repo_id (SeafileCloneTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_id;
	result = _tmp0_;
	return result;
}

void
seafile_clone_task_set_repo_id (SeafileCloneTask* self,
                                const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_clone_task_get_repo_id (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_repo_id);
		self->priv->_repo_id = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_clone_task_properties[SEAFILE_CLONE_TASK_REPO_ID_PROPERTY]);
	}
}

const gchar*
seafile_clone_task_get_repo_name (SeafileCloneTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_repo_name;
	result = _tmp0_;
	return result;
}

void
seafile_clone_task_set_repo_name (SeafileCloneTask* self,
                                  const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_clone_task_get_repo_name (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_repo_name);
		self->priv->_repo_name = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_clone_task_properties[SEAFILE_CLONE_TASK_REPO_NAME_PROPERTY]);
	}
}

const gchar*
seafile_clone_task_get_worktree (SeafileCloneTask* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_worktree;
	result = _tmp0_;
	return result;
}

void
seafile_clone_task_set_worktree (SeafileCloneTask* self,
                                 const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, seafile_clone_task_get_worktree (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_worktree);
		self->priv->_worktree = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, seafile_clone_task_properties[SEAFILE_CLONE_TASK_WORKTREE_PROPERTY]);
	}
}

static void
seafile_clone_task_class_init (SeafileCloneTaskClass * klass,
                               gpointer klass_data)
{
	seafile_clone_task_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &SeafileCloneTask_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_seafile_clone_task_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_seafile_clone_task_set_property;
	G_OBJECT_CLASS (klass)->finalize = seafile_clone_task_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CLONE_TASK_STATE_PROPERTY, seafile_clone_task_properties[SEAFILE_CLONE_TASK_STATE_PROPERTY] = g_param_spec_string ("state", "state", "state", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CLONE_TASK_ERROR_PROPERTY, seafile_clone_task_properties[SEAFILE_CLONE_TASK_ERROR_PROPERTY] = g_param_spec_int ("error", "error", "error", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CLONE_TASK_REPO_ID_PROPERTY, seafile_clone_task_properties[SEAFILE_CLONE_TASK_REPO_ID_PROPERTY] = g_param_spec_string ("repo-id", "repo-id", "repo-id", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CLONE_TASK_REPO_NAME_PROPERTY, seafile_clone_task_properties[SEAFILE_CLONE_TASK_REPO_NAME_PROPERTY] = g_param_spec_string ("repo-name", "repo-name", "repo-name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SEAFILE_CLONE_TASK_WORKTREE_PROPERTY, seafile_clone_task_properties[SEAFILE_CLONE_TASK_WORKTREE_PROPERTY] = g_param_spec_string ("worktree", "worktree", "worktree", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
seafile_clone_task_instance_init (SeafileCloneTask * self,
                                  gpointer klass)
{
	self->priv = seafile_clone_task_get_instance_private (self);
}

static void
seafile_clone_task_finalize (GObject * obj)
{
	SeafileCloneTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SEAFILE_TYPE_CLONE_TASK, SeafileCloneTask);
	_g_free0 (self->priv->_state);
	_g_free0 (self->priv->_repo_id);
	_g_free0 (self->priv->_repo_name);
	_g_free0 (self->priv->_worktree);
	G_OBJECT_CLASS (seafile_clone_task_parent_class)->finalize (obj);
}

GType
seafile_clone_task_get_type (void)
{
	static volatile gsize seafile_clone_task_type_id__volatile = 0;
	if (g_once_init_enter (&seafile_clone_task_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SeafileCloneTaskClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) seafile_clone_task_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SeafileCloneTask), 0, (GInstanceInitFunc) seafile_clone_task_instance_init, NULL };
		GType seafile_clone_task_type_id;
		seafile_clone_task_type_id = g_type_register_static (G_TYPE_OBJECT, "SeafileCloneTask", &g_define_type_info, 0);
		SeafileCloneTask_private_offset = g_type_add_instance_private (seafile_clone_task_type_id, sizeof (SeafileCloneTaskPrivate));
		g_once_init_leave (&seafile_clone_task_type_id__volatile, seafile_clone_task_type_id);
	}
	return seafile_clone_task_type_id__volatile;
}

static void
_vala_seafile_clone_task_get_property (GObject * object,
                                       guint property_id,
                                       GValue * value,
                                       GParamSpec * pspec)
{
	SeafileCloneTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_CLONE_TASK, SeafileCloneTask);
	switch (property_id) {
		case SEAFILE_CLONE_TASK_STATE_PROPERTY:
		g_value_set_string (value, seafile_clone_task_get_state (self));
		break;
		case SEAFILE_CLONE_TASK_ERROR_PROPERTY:
		g_value_set_int (value, seafile_clone_task_get_error (self));
		break;
		case SEAFILE_CLONE_TASK_REPO_ID_PROPERTY:
		g_value_set_string (value, seafile_clone_task_get_repo_id (self));
		break;
		case SEAFILE_CLONE_TASK_REPO_NAME_PROPERTY:
		g_value_set_string (value, seafile_clone_task_get_repo_name (self));
		break;
		case SEAFILE_CLONE_TASK_WORKTREE_PROPERTY:
		g_value_set_string (value, seafile_clone_task_get_worktree (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_seafile_clone_task_set_property (GObject * object,
                                       guint property_id,
                                       const GValue * value,
                                       GParamSpec * pspec)
{
	SeafileCloneTask * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SEAFILE_TYPE_CLONE_TASK, SeafileCloneTask);
	switch (property_id) {
		case SEAFILE_CLONE_TASK_STATE_PROPERTY:
		seafile_clone_task_set_state (self, g_value_get_string (value));
		break;
		case SEAFILE_CLONE_TASK_ERROR_PROPERTY:
		seafile_clone_task_set_error (self, g_value_get_int (value));
		break;
		case SEAFILE_CLONE_TASK_REPO_ID_PROPERTY:
		seafile_clone_task_set_repo_id (self, g_value_get_string (value));
		break;
		case SEAFILE_CLONE_TASK_REPO_NAME_PROPERTY:
		seafile_clone_task_set_repo_name (self, g_value_get_string (value));
		break;
		case SEAFILE_CLONE_TASK_WORKTREE_PROPERTY:
		seafile_clone_task_set_worktree (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

